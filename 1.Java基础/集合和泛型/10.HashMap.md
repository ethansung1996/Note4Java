# 10.HashMap

前面对于集合也了解的七七八八了，顺带的HashMap其实也不陌生了这里就直接深入验证一下。


## 底层实现原理
首先我们需要明白一个键值对其实构成了一个Entry对象，Entry对象里面包含了key和value两个属性。
我们底层HashMap存储的键值对其实都是存在了Entry（Node）数组中。

**添加底层实现流程分析**
```

以JDK7为例分析（8后面不太一样）
HashMap map = new HashMap():
在实例化以后，底层创建了长度是16的一维数组Entry[] table.
...可能已经执行过多次put...
map. put (key1, value1): .
首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry 数组中的存放位置也就是数组的索引值，
-如果此位置上的数据为空，此时的key1-value1 添加成功。直接就放在数组当前索引下的位置	---- 情况1
-如果此位置_上的数据不为空，(意味者此位置上存在一个或多个数据(以链表形式连接存在)),比较key1和已经存在的一个或多个数据的哈希值:
	--如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1 添加成功。	---- 情况2 
	--如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同， 继续比较:调用key1所在类的equals(key2)
		---如果equals()返回false:此时key1-value1添加成功。---- 情况3
		---如果equals().返回true:使用value1覆盖vaLue2。
在不断地添加过程中，涉及到扩容的话，默认扩容方式：扩容为原来的2倍，并将原来的数据复制过来。

jdk8相较于jdk7在底层实现方面的不同:
1. new HashMap():底层没有创建一个 长度为16的数组
2. jdk 8底层的数组是: Node[], 而非Entry[]
3. 首次调用put()方法时， 底层创建长度为16的数组
4. jdk7底层结构只有:数组+链表。jdk8中底层结构:数组+链表+红黑树。
当数组的某一个索引位置上的元素以链表形式存在的数据个数>8且当前数组的长度>64时，此时此索引位置上的所有数据改为使用红黑树存储。这样遍历查找效率更高，复杂度是log2N.

```

## 源码分析验证


















